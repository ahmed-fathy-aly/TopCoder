<html><head><title>MultiplicationTable2Easy</title></head><body  ><table><tr><td colspan="2"><h3>Problem Statement</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td>Fox Ciel is creating a new binary operation.<br></br>
<br></br>
The operation will be denoted $ and it will be defined on the finite set S = {0, 1, 2, ..., n-1}.
I.e., for each ordered pair (i, j) of elements of S the operation (i $ j) will return some element of S.<br></br>
<br></br>
For example, we can have S = {0, 1}, and we can define that (0 $ 0) = 0, (0 $ 1) = 1, (1 $ 0) = 0, and (1 $ 1) = 0.<br></br>
<br></br>
Note that Ciel's operation is not necessarily symmetric.
In other words, it is possible that for some i and j the operations (i $ j) and (j $ i) return two different values.<br></br>
<br></br>
A nice concise description of the operation $ is its "multiplication table": a square table where in row i and column j we have the value (i $ j).
You are given this "multiplication table" encoded as a int[] <b>table</b> with n^2 elements.
For each valid i and j the operation (i $ j) returns the value <b>table</b>[i*n+j].<br></br>
<br></br>
A subset T of S is called <i>good</i> if it has the following property:
for any two elements i and j in T, (i $ j) is also in T.<br></br>
<br></br>
You are given a int[] <b>t</b>.
The elements of <b>t</b> form a subset of the set S.
Return "Good" (quotes for clarity) if this subset is good.
Otherwise, return "Not Good".
Note that the return value is case-sensitive.</td></tr><tr><td colspan="2"><h3>Definition</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td>Class:</td><td>MultiplicationTable2Easy</td></tr><tr><td>Method:</td><td>isGoodSet</td></tr><tr><td>Parameters:</td><td>int[], int[]</td></tr><tr><td>Returns:</td><td>String</td></tr><tr><td>Method signature:</td><td>String isGoodSet(int[] table, int[] t)</td></tr><tr><td colspan="2">(be sure your method is public)</td></tr></table></td></tr><tr><td colspan="2"><h3>Limits</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td>Time limit (s):</td><td>2.000</td></tr><tr><td>Memory limit (MB):</td><td>256</td></tr><tr><td>Stack limit (MB):</td><td>256</td></tr></table></td></tr><tr><td colspan="2"><h3>Notes</h3></td></tr><tr><td align="center" valign="top">-</td><td>You are not given the value of n explicitly. Instead, you can determine it as the square root of the number of elements in <b>table</b>.</td></tr><tr><td colspan="2"><h3>Constraints</h3></td></tr><tr><td align="center" valign="top">-</td><td>n will be between 2 and 50, inclusive.</td></tr><tr><td align="center" valign="top">-</td><td><b>table</b> will contain exactly n*n elements.</td></tr><tr><td align="center" valign="top">-</td><td>Each element in <b>table</b> will be between 0 and n-1, inclusive.</td></tr><tr><td align="center" valign="top">-</td><td><b>t</b> will contain between 1 and n elements, inclusive.</td></tr><tr><td align="center" valign="top">-</td><td>Each element in <b>t</b> will be between 0 and n-1, inclusive.</td></tr><tr><td align="center" valign="top">-</td><td>Elements in <b>t</b> will be distinct.</td></tr><tr><td colspan="2"><h3>Examples</h3></td></tr><tr><td align="center" nowrap="true">0)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{1, 1, 2, 3,
 1, 0, 2, 3,
 3, 3, 0, 3,
 2, 2, 2, 0}
</pre></td></tr><tr><td><pre>{1,0}</pre></td></tr></table></td></tr><tr><td><pre>Returns: &quot;Good&quot;</pre></td></tr><tr><td><table><tr><td colspan="2">We can verify:
<ul>
<li>0 $ 0 = 1</li>
<li>0 $ 1 = 1</li>
<li>1 $ 0 = 1</li>
<li>1 $ 1 = 0</li>
</ul></td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">1)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{1, 1, 2, 3,
 1, 0, 2, 3,
 3, 3, 0, 3,
 2, 2, 2, 0}</pre></td></tr><tr><td><pre>{2, 3}</pre></td></tr></table></td></tr><tr><td><pre>Returns: &quot;Not Good&quot;</pre></td></tr><tr><td><table><tr><td colspan="2">Note that: 2 $ 2 = 0 but 0 is not in T, so it is not good.</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">2)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{1, 1, 2, 3,
 1, 0, 2, 3,
 3, 3, 0, 3,
 2, 2, 2, 0}
</pre></td></tr><tr><td><pre>{0,1,2,3}</pre></td></tr></table></td></tr><tr><td><pre>Returns: &quot;Good&quot;</pre></td></tr><tr><td><table><tr><td colspan="2"></td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">3)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{1, 1, 2, 3,
 1, 0, 2, 3,
 3, 3, 0, 3,
 2, 2, 2, 0}
</pre></td></tr><tr><td><pre>{1}</pre></td></tr></table></td></tr><tr><td><pre>Returns: &quot;Not Good&quot;</pre></td></tr><tr><td><table><tr><td colspan="2"></td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">4)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{2,2,2,2,2,2,
 2,2,2,2,2,2,
 2,2,2,2,2,2,
 2,2,2,2,2,2,
 2,2,2,2,2,2,
 2,2,2,2,2,2}</pre></td></tr><tr><td><pre>{2,4,5}</pre></td></tr></table></td></tr><tr><td><pre>Returns: &quot;Good&quot;</pre></td></tr><tr><td><table><tr><td colspan="2"></td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">5)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{2,2,2,2,2,2,
 2,2,2,2,2,2,
 2,2,2,2,2,2,
 2,2,2,2,2,2,
 2,2,2,2,2,2,
 2,2,2,2,2,2}</pre></td></tr><tr><td><pre>{0,1,3,4,5}</pre></td></tr></table></td></tr><tr><td><pre>Returns: &quot;Not Good&quot;</pre></td></tr><tr><td><table><tr><td colspan="2"></td></tr></table></td></tr></table></td></tr></table><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc.  Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited.  (c)2003, TopCoder, Inc.  All rights reserved.  </p></body></html>