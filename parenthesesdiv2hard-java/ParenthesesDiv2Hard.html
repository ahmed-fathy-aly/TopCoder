<html><head><title>ParenthesesDiv2Hard</title></head><body  ><table><tr><td colspan="2"><h3>Problem Statement</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td>Correct parentheses sequences can be defined recursively as follows:
<ul>
<li>The empty string "" is a correct sequence.</li>
<li>If "X" and "Y" are correct sequences, then "XY" (the concatenation of X and Y) is a correct sequence.</li>
<li>If "X" is a correct sequence, then "(X)" is a correct sequence.</li>
<li>Each correct parentheses sequence can be derived using the above rules.</li>
</ul>
Examples of correct parentheses sequences include "", "()", "()()()", "(()())", and "(((())))".<br></br>
<br></br>
<br></br>
You are given a String <b>s</b>.
You are also given int[]s <b>L</b> and <b>R</b>, each with the same number of elements.
These encode a set of conditions.
For each valid i, you have to satisfy the following condition:
the substring of <b>s</b> that begins at the 0-based index <b>L</b>[i] and ends at the 0-based index <b>R</b>[i] must be a correct parentheses sequence.
Note that the constraints guarantee that all the given ranges of indices are pairwise disjoint.<br></br>
<br></br>
<br></br>
You can only modify <b>s</b> in one way: in each step you can choose two characters of <b>s</b> and swap them.
Return the minimal number of swaps needed to produce a string that satisfies all the given conditions.
If it is impossible, return -1 instead.</td></tr><tr><td colspan="2"><h3>Definition</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td>Class:</td><td>ParenthesesDiv2Hard</td></tr><tr><td>Method:</td><td>minSwaps</td></tr><tr><td>Parameters:</td><td>String, int[], int[]</td></tr><tr><td>Returns:</td><td>int</td></tr><tr><td>Method signature:</td><td>int minSwaps(String s, int[] L, int[] R)</td></tr><tr><td colspan="2">(be sure your method is public)</td></tr></table></td></tr><tr><td colspan="2"><h3>Limits</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td>Time limit (s):</td><td>2.000</td></tr><tr><td>Memory limit (MB):</td><td>256</td></tr><tr><td>Stack limit (MB):</td><td>256</td></tr></table></td></tr><tr><td colspan="2"><h3>Constraints</h3></td></tr><tr><td align="center" valign="top">-</td><td><b>s</b> will contain between 1 and 50 characters, inclusive.</td></tr><tr><td align="center" valign="top">-</td><td>Each character in <b>s</b> will be '(' or ')'.</td></tr><tr><td align="center" valign="top">-</td><td><b>L</b> will contain between 1 and 50 elements, inclusive.</td></tr><tr><td align="center" valign="top">-</td><td><b>L</b> and <b>R</b> will contain the same number of elements.</td></tr><tr><td align="center" valign="top">-</td><td>For each valid i, 0 &lt;= L[i] &lt;= R[i] &lt; |<b>s</b>|.</td></tr><tr><td align="center" valign="top">-</td><td>For different i and j, intervals [(<b>L</b>[i]), (<b>R</b>[i])] and [(<b>L</b>[j]), (<b>R</b>[j])] will not intersect.</td></tr><tr><td colspan="2"><h3>Examples</h3></td></tr><tr><td align="center" nowrap="true">0)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>&quot;)(&quot;</pre></td></tr><tr><td><pre>{0}</pre></td></tr><tr><td><pre>{1}</pre></td></tr></table></td></tr><tr><td><pre>Returns: 1</pre></td></tr><tr><td><table><tr><td colspan="2">We have one condition:
The substring that begins at index 0 and ends at index 1 must be a correct parentheses sequence.<br></br>
In this case, this means that the entire string <b>s</b> must be a correct parentheses sequence.<br></br>
<br></br>
We can achieve that by swapping <b>s</b>[0] with <b>s</b>[1].<br></br>
This swap produces the string "()".</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">1)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>&quot;(())&quot;</pre></td></tr><tr><td><pre>{0,2}</pre></td></tr><tr><td><pre>{1,3}</pre></td></tr></table></td></tr><tr><td><pre>Returns: 1</pre></td></tr><tr><td><table><tr><td colspan="2">The only way to satisfy both conditions is to change <b>s</b> into "()()".<br></br>
This can be done in 1 swap: by swapping <b>s</b>[1] with <b>s</b>[2].</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">2)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>&quot;(((())&quot;</pre></td></tr><tr><td><pre>{0,2}</pre></td></tr><tr><td><pre>{1,3}</pre></td></tr></table></td></tr><tr><td><pre>Returns: 2</pre></td></tr><tr><td><table><tr><td colspan="2">This time we do swap(s[1],s[4]) and swap(s[3],s[5]).</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">3)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>&quot;(((((((((&quot;</pre></td></tr><tr><td><pre>{0,2}</pre></td></tr><tr><td><pre>{1,3}</pre></td></tr></table></td></tr><tr><td><pre>Returns: -1</pre></td></tr><tr><td><table><tr><td colspan="2"></td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">4)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>&quot;))()())((()()()()()())))((((((&quot;</pre></td></tr><tr><td><pre>{1,6,13,17,23,25}</pre></td></tr><tr><td><pre>{4,7,16,20,24,28}</pre></td></tr></table></td></tr><tr><td><pre>Returns: 5</pre></td></tr><tr><td><table><tr><td colspan="2"></td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">5)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>&quot;(&quot;</pre></td></tr><tr><td><pre>{0}</pre></td></tr><tr><td><pre>{0}</pre></td></tr></table></td></tr><tr><td><pre>Returns: -1</pre></td></tr><tr><td><table><tr><td colspan="2"></td></tr></table></td></tr></table></td></tr></table><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc.  Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited.  (c)2003, TopCoder, Inc.  All rights reserved.  </p></body></html>